#summary JUnit
#labels Junit,test,java,j2ee

= What´s it? =

Junit es un frameworks para automatizar las pruebas unitarias de aplicaciones Java. Es un software de código abierto. Fue creado por Erich Gamma  y Kent Beck. 
Consta de un conjunto de clases que el programador puede utilizar para construir sus casos de prueba y ejecutarlos automáticamente.
Los casos de prueba son realmente programas Java. Quedan archivados y pueden ser reejecutados tantas veces como sea necesario.
Es adecuado para el desarrollo dirigido por las pruebas. Test-driven develoment, tecnología planteada hace poco años que sostiene que no hay que programar y luego hacer un test que lo pruebe, sino que hay que hacer un test que tenga las entradas y las salidas que nosotros queremos y luego implementar el código que se necesite para solucionarlo.

= How does it work? =

Los test de Junit se ejecutan como una clase Java normal, aunque tienen una clase de inyecciones y anotaciones que lo hacen un poco especial. Por lo tanto la mejor manera de ejecutar estos test es por medio de otra aplicación que sea capaz de interpretarlos de la mejor manera. La forma más utilizada es por maven, ant o por algún IDE que ya tenga bien integradas las pruebas unitarias dentro de sus características.

Junit proporciona una Api para la ejecución de los test. Tiene una serie de clases y objetos que facilitan el testeo.

Todos los test en Junit tienen que llevar la anotación:
@RunWith(SpringJUnit4ClassRunner.class)
Esta anotación expresa que vamos a realizar un test en Junit utilizando spring.

La siguiente anotación:
{{{
@ContextConfiguration(locations = {
        "classpath:/spring/applicationContext-resources.xml",
        "classpath:/spring/applicationContext-dao.xml",
        "classpath:/spring/applicationContext-service.xml" })
}}}
Se usa para especificar el contexto de Spring que es necesario para que el test se ejecute correctamente.

Cada método que sirva de test de otro método de la aplicación hay que catalogarlos con la anotación 
@Test


= Instalation =

Maven utiliza determinados ciclos de vida solo para la ejecución de test. Teniendo como dependencia la Api de Junit:
{{{
<dependency>
<groupId>junit</groupId>
<artifactId>junit</artifactId>
<version>4.5</version>
<scope>test</scope>
</dependency>
}}}
Los beans de spring necesitan ser inyectados para las pruebas. Spring ha resuelto este mecanismo pero hay que inyectar la dependencia a spring-test.
{{{
<dependency>
<groupId>org.springframework</groupId>
<artifactId>spring-test</artifactId>
<version>3.0.3.RELEASE</version>
</dependency>
}}}
= Use =

El ejemplo se va a presentar con la clase ICityDao.java
{{{
package org.archetypeUma.dao;
import static org.junit.Assert.assertEquals;
import java.util.List;
import org.archetypeUma.dao.interfaces.ICityDao;
import org.archetypeUma.model.pojos.City;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {
        "classpath:/spring/applicationContext-resources.xml",
        "classpath:/spring/applicationContext-dao.xml",
        "classpath:/spring/applicationContext-service.xml" })
public class ICityDaoTest {
    @Autowired
    private ICityDao cityDao;
    @Test
    public void testGetAll() {
        List<City> cities = cityDao.getAll();
        assertEquals(3, cities.size());
}
    // Getters & Setters
    public void setCityDao(ICityDao cityDao) {
        this.cityDao = cityDao;
    }
}
}}}
Hay que inyectar la capa DAO con @Autowired y probar uno a uno todos los métodos de esta capa. En este caso se ha probado el método getAll. Se ha llegado a la conclusión de que funciona correctamente ya que en la base de datos hay 3 ciudades que han sido precargada con el sample-data.xml y es lo que este método ha obtenido.

= Links=

 * www.junit.org

= ¿Qué es? =

Junit es un frameworks para automatizar las pruebas unitarias de aplicaciones Java. Es un software de código abierto. Fue creado por Erich Gamma  y Kent Beck. 
Consta de un conjunto de clases que el programador puede utilizar para construir sus casos de prueba y ejecutarlos automáticamente.
Los casos de prueba son realmente programas Java. Quedan archivados y pueden ser reejecutados tantas veces como sea necesario.
Es adecuado para el desarrollo dirigido por las pruebas. Test-driven develoment, tecnología planteada hace poco años que sostiene que no hay que programar y luego hacer un test que lo pruebe, sino que hay que hacer un test que tenga las entradas y las salidas que nosotros queremos y luego implementar el código que se necesite para solucionarlo.

= ¿Como funciona ? =

Los test de Junit se ejecutan como una clase Java normal, aunque tienen una clase de inyecciones y anotaciones que lo hacen un poco especial. Por lo tanto la mejor manera de ejecutar estos test es por medio de otra aplicación que sea capaz de interpretarlos de la mejor manera. La forma más utilizada es por maven, ant o por algún IDE que ya tenga bien integradas las pruebas unitarias dentro de sus características.

Junit proporciona una Api para la ejecución de los test. Tiene una serie de clases y objetos que facilitan el testeo.

Todos los test en Junit tienen que llevar la anotación:
@RunWith(SpringJUnit4ClassRunner.class)
Esta anotación expresa que vamos a realizar un test en Junit utilizando spring.

La siguiente anotación:
{{{
@ContextConfiguration(locations = {
        "classpath:/spring/applicationContext-resources.xml",
        "classpath:/spring/applicationContext-dao.xml",
        "classpath:/spring/applicationContext-service.xml" })
}}}
Se usa para especificar el contexto de Spring que es necesario para que el test se ejecute correctamente.

Cada método que sirva de test de otro método de la aplicación hay que catalogarlos con la anotación 
@Test

= Instalación =

Maven utiliza determinados ciclos de vida solo para la ejecución de test. Teniendo como dependencia la Api de Junit:
{{{
<dependency>
<groupId>junit</groupId>
<artifactId>junit</artifactId>
<version>4.5</version>
<scope>test</scope>
</dependency>
}}}
Los beans de spring necesitan ser inyectados para las pruebas. Spring ha resuelto este mecanismo pero hay que inyectar la dependencia a spring-test.
{{{
<dependency>
<groupId>org.springframework</groupId>
<artifactId>spring-test</artifactId>
<version>3.0.3.RELEASE</version>
</dependency>
}}}
= Uso =

El ejemplo se va a presentar con la clase ICityDao.java
{{{
package org.archetypeUma.dao;
import static org.junit.Assert.assertEquals;
import java.util.List;
import org.archetypeUma.dao.interfaces.ICityDao;
import org.archetypeUma.model.pojos.City;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {
        "classpath:/spring/applicationContext-resources.xml",
        "classpath:/spring/applicationContext-dao.xml",
        "classpath:/spring/applicationContext-service.xml" })
public class ICityDaoTest {
    @Autowired
    private ICityDao cityDao;
    @Test
    public void testGetAll() {
        List<City> cities = cityDao.getAll();
        assertEquals(3, cities.size());
}
    // Getters & Setters
    public void setCityDao(ICityDao cityDao) {
        this.cityDao = cityDao;
    }
}
}}}
Hay que inyectar la capa DAO con @Autowired y probar uno a uno todos los métodos de esta capa. En este caso se ha probado el método getAll. Se ha llegado a la conclusión de que funciona correctamente ya que en la base de datos hay 3 ciudades que han sido precargada con el sample-data.xml y es lo que este método ha obtenido.

= Enlaces =

 * www.junit.org